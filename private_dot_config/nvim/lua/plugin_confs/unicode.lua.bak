-- Save this as lua/unicode_picker.lua
local M = {}

local has_snacks_picker, snacks_picker = pcall(require, "snacks.picker")
if not has_snacks_picker then
  error("This plugin requires folke/snacks.nvim")
end

-- Set default values for highlighting groups
vim.cmd("highlight default link PickerUnicodeChar Number")
vim.cmd("highlight default link PickerUnicodeName Comment")
vim.cmd("highlight default link PickerUnicodeCodepoint Special")

local defaults = {
  unicode_url = "https://www.unicode.org/Public/UNIDATA/UnicodeData.txt",
  data_directory = nil, -- Will use stdpath('data')/site/unicode
  cache_directory = nil, -- Will use stdpath('cache')/unicode
  use_cache = true,
}

-- Cache the loaded data in memory
local unicode_data_cache = nil

-- Get the data file path (raw Unicode data)
local function get_data_file()
  local data_dir = M.opts.data_directory or (vim.fn.stdpath("data") .. "/site/unicode")
  return data_dir .. "/UnicodeData.txt"
end

-- Get cache file path (processed Lua cache)
local function get_cache_file()
  local cache_dir = M.opts.cache_directory or (vim.fn.stdpath("cache") .. "/unicode")
  return cache_dir .. "/UnicodeData.lua"
end

-- Ensure directory exists
local function ensure_dir(dir)
  if vim.fn.isdirectory(dir) == 0 then
    local ok = vim.fn.mkdir(dir, "p")
    if ok == 0 then
      vim.notify("Error creating directory: " .. dir, vim.log.levels.ERROR, { title = "Unicode Picker" })
      return false
    end
  end
  return true
end

-- Download Unicode data file
local function download_unicode_data(force)
  local data_file = get_data_file()
  local data_dir = vim.fn.fnamemodify(data_file, ":h")

  -- Check if file exists and is not empty
  if not force and vim.fn.filereadable(data_file) == 1 and vim.fn.getfsize(data_file) > 0 then
    return true
  end

  if not ensure_dir(data_dir) then
    return false
  end

  vim.notify("Downloading Unicode data from unicode.org...", vim.log.levels.INFO, { title = "Unicode Picker" })

  -- Check if curl is available
  if vim.fn.executable("curl") == 0 then
    vim.notify(
      "curl not found. Please download manually:\n" .. M.opts.unicode_url .. "\nand save it as:\n" .. data_file,
      vim.log.levels.ERROR,
      { title = "Unicode Picker" }
    )
    return false
  end

  -- Download using curl
  local cmd = string.format("curl -fsSL -o '%s' '%s'", data_file, M.opts.unicode_url)
  local result = vim.fn.system(cmd)

  if vim.v.shell_error ~= 0 then
    vim.notify("Error downloading Unicode data:\n" .. result, vim.log.levels.ERROR, { title = "Unicode Picker" })
    return false
  end

  -- Verify the downloaded file
  if vim.fn.getfsize(data_file) == 0 then
    vim.notify("Downloaded file is empty", vim.log.levels.ERROR, { title = "Unicode Picker" })
    vim.fn.delete(data_file)
    return false
  end

  vim.notify("Unicode data downloaded successfully", vim.log.levels.INFO, { title = "Unicode Picker" })

  -- Clear memory and file cache
  unicode_data_cache = nil
  local cache_file = get_cache_file()
  if vim.fn.filereadable(cache_file) == 1 then
    vim.fn.delete(cache_file)
  end

  return true
end

-- Parse Unicode data file and create cache
local function create_cache()
  local data_file = get_data_file()
  local cache_file = get_cache_file()
  local cache_dir = vim.fn.fnamemodify(cache_file, ":h")

  if not ensure_dir(cache_dir) then
    return false
  end

  -- Check if data file exists
  if vim.fn.filereadable(data_file) == 0 then
    vim.notify(
      "Unicode data file not found. Attempting to download...",
      vim.log.levels.WARN,
      { title = "Unicode Picker" }
    )
    if not download_unicode_data(false) then
      return false
    end
  end

  vim.notify("Creating Unicode cache...", vim.log.levels.INFO, { title = "Unicode Picker" })

  -- Read and parse the data file
  local lines = vim.fn.readfile(data_file)
  local unicode_data = {}

  for _, line in ipairs(lines) do
    -- Parse line: codepoint;name;category;...
    local parts = vim.split(line, ";")
    if #parts >= 2 then
      local codepoint = tonumber(parts[1], 16)
      local name = parts[2]

      -- Skip empty names and control characters
      if codepoint and name and name ~= "" and name ~= "<control>" then
        unicode_data[codepoint] = name
      end
    end
  end

  -- Store in memory cache
  unicode_data_cache = unicode_data

  -- Write cache file
  local cache_content = {
    "-- Auto-generated Unicode cache file",
    "-- This file can be safely deleted, it will be regenerated if needed",
    "return " .. vim.inspect(unicode_data),
  }

  local ok = vim.fn.writefile(cache_content, cache_file)
  if ok == -1 then
    vim.notify("Error writing cache file", vim.log.levels.ERROR, { title = "Unicode Picker" })
    return false
  end

  vim.notify(
    string.format("Cache created with %d characters", vim.tbl_count(unicode_data)),
    vim.log.levels.INFO,
    { title = "Unicode Picker" }
  )

  return true
end

-- Load unicode data from cache
local function load_unicode_data()
  -- Return cached data if available
  if unicode_data_cache then
    return unicode_data_cache
  end

  local cache_file = get_cache_file()
  local data_file = get_data_file()

  -- Check if cache exists and is valid
  local cache_exists = vim.fn.filereadable(cache_file) == 1
  local data_exists = vim.fn.filereadable(data_file) == 1

  if M.opts.use_cache and cache_exists and vim.fn.getfsize(cache_file) > 100 then
    -- Try to load from cache
    local cache_content = vim.fn.readfile(cache_file)
    local ok, unicode_data_func = pcall(loadstring, table.concat(cache_content, "\n"))
    if ok and unicode_data_func then
      local success, unicode_data = pcall(unicode_data_func)
      if success and type(unicode_data) == "table" and next(unicode_data) then
        unicode_data_cache = unicode_data
        return unicode_data_cache
      end
    end
  end

  -- Need to download or create cache
  if not data_exists then
    vim.notify("Unicode data not found. Downloading...", vim.log.levels.INFO, { title = "Unicode Picker" })
    if not download_unicode_data(false) then
      return {}
    end
  end

  -- Create cache
  if not create_cache() then
    return {}
  end

  -- Return the newly cached data
  return unicode_data_cache or {}
end

-- Create items for the picker
local function create_unicode_items()
  local unicode_data = load_unicode_data()

  if not unicode_data or vim.tbl_count(unicode_data) == 0 then
    vim.notify(
      "No Unicode data available. Run :UnicodeDownload to download data.",
      vim.log.levels.ERROR,
      { title = "Unicode Picker" }
    )
    return {}
  end

  local results = {}

  for codepoint, name in pairs(unicode_data) do
    local char = vim.fn.nr2char(codepoint)
    table.insert(results, {
      codepoint = codepoint,
      char = char,
      name = name,
      text = char .. " " .. name, -- Used for fuzzy matching
    })
  end

  return results
end

-- Format a codepoint as hex (e.g., U+1F600)
local function format_codepoint(codepoint)
  return string.format("U+%04X", codepoint)
end

-- Base unicode picker configuration
local function unicode_picker()
  return {
    win = {
      title = "Unicode Picker",
      input = {
        keys = {
          ["<Tab>"] = { "toggle", mode = { "n", "i" } },
        },
      },
    },
    -- Disable preview since we don't have files
    layout = {
      preset = "select",
    },
    finder = create_unicode_items,
    format = function(item)
      local ret = {}
      -- Codepoint (e.g., U+1F600)
      ret[#ret + 1] = { format_codepoint(item.codepoint), "PickerUnicodeCodepoint" }
      ret[#ret + 1] = { "  " }
      -- Character
      ret[#ret + 1] = { item.char, "PickerUnicodeChar" }
      ret[#ret + 1] = { "\t" }
      -- Name
      ret[#ret + 1] = { item.name, "PickerUnicodeName" }
      return ret
    end,
    confirm = function(picker, _)
      local items = picker:selected({ fallback = true })
      picker:close()

      local chars = ""
      for _, item in ipairs(items) do
        chars = chars .. item.char
      end

      -- Insert at cursor position
      if chars ~= "" then
        local col = vim.fn.col(".")
        local mode = col < vim.fn.col("$") and "i" or "A"
        vim.api.nvim_feedkeys(vim.api.nvim_replace_termcodes(mode .. chars .. "<Esc>", true, false, true), "n", false)
      end
    end,
  }
end

function M.setup(opts)
  M.opts = vim.tbl_deep_extend("force", defaults, opts or {})

  -- Register the unicode picker source
  snacks_picker.sources.unicode = unicode_picker()

  -- Create commands
  vim.api.nvim_create_user_command("UnicodePicker", function()
    snacks_picker.pick("unicode")
  end, { desc = "Open Unicode character picker" })

  vim.api.nvim_create_user_command("UnicodeDownload", function(cmd)
    download_unicode_data(cmd.bang)
  end, {
    bang = true,
    desc = "Download Unicode data (use ! to force re-download)",
  })

  vim.api.nvim_create_user_command("UnicodeCache", function()
    create_cache()
  end, { desc = "Create or update Unicode cache" })

  vim.api.nvim_create_user_command("UnicodeClearCache", function()
    unicode_data_cache = nil
    vim.notify("Memory cache cleared", vim.log.levels.INFO, { title = "Unicode Picker" })
  end, { desc = "Clear Unicode memory cache" })
end

return M
